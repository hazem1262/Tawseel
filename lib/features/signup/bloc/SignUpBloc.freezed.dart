// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'SignUpBloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$SignUpEvents {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() signUpWithGoogle,
    required TResult Function() signUpWithApple,
    required TResult Function(String fullName, String phone, String password, CAN_RECEIVE_OFFERS can_receive_offers)
        signUpWithPhone,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? signUpWithGoogle,
    TResult? Function()? signUpWithApple,
    TResult? Function(String fullName, String phone, String password, CAN_RECEIVE_OFFERS can_receive_offers)?
        signUpWithPhone,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? signUpWithGoogle,
    TResult Function()? signUpWithApple,
    TResult Function(String fullName, String phone, String password, CAN_RECEIVE_OFFERS can_receive_offers)?
        signUpWithPhone,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SignUpWithGoogle value) signUpWithGoogle,
    required TResult Function(SignUpWithApple value) signUpWithApple,
    required TResult Function(SignUpWithPhone value) signUpWithPhone,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SignUpWithGoogle value)? signUpWithGoogle,
    TResult? Function(SignUpWithApple value)? signUpWithApple,
    TResult? Function(SignUpWithPhone value)? signUpWithPhone,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SignUpWithGoogle value)? signUpWithGoogle,
    TResult Function(SignUpWithApple value)? signUpWithApple,
    TResult Function(SignUpWithPhone value)? signUpWithPhone,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SignUpEventsCopyWith<$Res> {
  factory $SignUpEventsCopyWith(SignUpEvents value, $Res Function(SignUpEvents) then) =
      _$SignUpEventsCopyWithImpl<$Res, SignUpEvents>;
}

/// @nodoc
class _$SignUpEventsCopyWithImpl<$Res, $Val extends SignUpEvents> implements $SignUpEventsCopyWith<$Res> {
  _$SignUpEventsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$SignUpWithGoogleCopyWith<$Res> {
  factory _$$SignUpWithGoogleCopyWith(_$SignUpWithGoogle value, $Res Function(_$SignUpWithGoogle) then) =
      __$$SignUpWithGoogleCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SignUpWithGoogleCopyWithImpl<$Res> extends _$SignUpEventsCopyWithImpl<$Res, _$SignUpWithGoogle>
    implements _$$SignUpWithGoogleCopyWith<$Res> {
  __$$SignUpWithGoogleCopyWithImpl(_$SignUpWithGoogle _value, $Res Function(_$SignUpWithGoogle) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SignUpWithGoogle with DiagnosticableTreeMixin implements SignUpWithGoogle {
  const _$SignUpWithGoogle();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'SignUpEvents.signUpWithGoogle()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'SignUpEvents.signUpWithGoogle'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other.runtimeType == runtimeType && other is _$SignUpWithGoogle);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() signUpWithGoogle,
    required TResult Function() signUpWithApple,
    required TResult Function(String fullName, String phone, String password, CAN_RECEIVE_OFFERS can_receive_offers)
        signUpWithPhone,
  }) {
    return signUpWithGoogle();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? signUpWithGoogle,
    TResult? Function()? signUpWithApple,
    TResult? Function(String fullName, String phone, String password, CAN_RECEIVE_OFFERS can_receive_offers)?
        signUpWithPhone,
  }) {
    return signUpWithGoogle?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? signUpWithGoogle,
    TResult Function()? signUpWithApple,
    TResult Function(String fullName, String phone, String password, CAN_RECEIVE_OFFERS can_receive_offers)?
        signUpWithPhone,
    required TResult orElse(),
  }) {
    if (signUpWithGoogle != null) {
      return signUpWithGoogle();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SignUpWithGoogle value) signUpWithGoogle,
    required TResult Function(SignUpWithApple value) signUpWithApple,
    required TResult Function(SignUpWithPhone value) signUpWithPhone,
  }) {
    return signUpWithGoogle(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SignUpWithGoogle value)? signUpWithGoogle,
    TResult? Function(SignUpWithApple value)? signUpWithApple,
    TResult? Function(SignUpWithPhone value)? signUpWithPhone,
  }) {
    return signUpWithGoogle?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SignUpWithGoogle value)? signUpWithGoogle,
    TResult Function(SignUpWithApple value)? signUpWithApple,
    TResult Function(SignUpWithPhone value)? signUpWithPhone,
    required TResult orElse(),
  }) {
    if (signUpWithGoogle != null) {
      return signUpWithGoogle(this);
    }
    return orElse();
  }
}

abstract class SignUpWithGoogle implements SignUpEvents {
  const factory SignUpWithGoogle() = _$SignUpWithGoogle;
}

/// @nodoc
abstract class _$$SignUpWithAppleCopyWith<$Res> {
  factory _$$SignUpWithAppleCopyWith(_$SignUpWithApple value, $Res Function(_$SignUpWithApple) then) =
      __$$SignUpWithAppleCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SignUpWithAppleCopyWithImpl<$Res> extends _$SignUpEventsCopyWithImpl<$Res, _$SignUpWithApple>
    implements _$$SignUpWithAppleCopyWith<$Res> {
  __$$SignUpWithAppleCopyWithImpl(_$SignUpWithApple _value, $Res Function(_$SignUpWithApple) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SignUpWithApple with DiagnosticableTreeMixin implements SignUpWithApple {
  const _$SignUpWithApple();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'SignUpEvents.signUpWithApple()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'SignUpEvents.signUpWithApple'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other.runtimeType == runtimeType && other is _$SignUpWithApple);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() signUpWithGoogle,
    required TResult Function() signUpWithApple,
    required TResult Function(String fullName, String phone, String password, CAN_RECEIVE_OFFERS can_receive_offers)
        signUpWithPhone,
  }) {
    return signUpWithApple();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? signUpWithGoogle,
    TResult? Function()? signUpWithApple,
    TResult? Function(String fullName, String phone, String password, CAN_RECEIVE_OFFERS can_receive_offers)?
        signUpWithPhone,
  }) {
    return signUpWithApple?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? signUpWithGoogle,
    TResult Function()? signUpWithApple,
    TResult Function(String fullName, String phone, String password, CAN_RECEIVE_OFFERS can_receive_offers)?
        signUpWithPhone,
    required TResult orElse(),
  }) {
    if (signUpWithApple != null) {
      return signUpWithApple();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SignUpWithGoogle value) signUpWithGoogle,
    required TResult Function(SignUpWithApple value) signUpWithApple,
    required TResult Function(SignUpWithPhone value) signUpWithPhone,
  }) {
    return signUpWithApple(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SignUpWithGoogle value)? signUpWithGoogle,
    TResult? Function(SignUpWithApple value)? signUpWithApple,
    TResult? Function(SignUpWithPhone value)? signUpWithPhone,
  }) {
    return signUpWithApple?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SignUpWithGoogle value)? signUpWithGoogle,
    TResult Function(SignUpWithApple value)? signUpWithApple,
    TResult Function(SignUpWithPhone value)? signUpWithPhone,
    required TResult orElse(),
  }) {
    if (signUpWithApple != null) {
      return signUpWithApple(this);
    }
    return orElse();
  }
}

abstract class SignUpWithApple implements SignUpEvents {
  const factory SignUpWithApple() = _$SignUpWithApple;
}

/// @nodoc
abstract class _$$SignUpWithPhoneCopyWith<$Res> {
  factory _$$SignUpWithPhoneCopyWith(_$SignUpWithPhone value, $Res Function(_$SignUpWithPhone) then) =
      __$$SignUpWithPhoneCopyWithImpl<$Res>;
  @useResult
  $Res call({String fullName, String phone, String password, CAN_RECEIVE_OFFERS can_receive_offers});
}

/// @nodoc
class __$$SignUpWithPhoneCopyWithImpl<$Res> extends _$SignUpEventsCopyWithImpl<$Res, _$SignUpWithPhone>
    implements _$$SignUpWithPhoneCopyWith<$Res> {
  __$$SignUpWithPhoneCopyWithImpl(_$SignUpWithPhone _value, $Res Function(_$SignUpWithPhone) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fullName = null,
    Object? phone = null,
    Object? password = null,
    Object? can_receive_offers = null,
  }) {
    return _then(_$SignUpWithPhone(
      null == fullName
          ? _value.fullName
          : fullName // ignore: cast_nullable_to_non_nullable
              as String,
      null == phone
          ? _value.phone
          : phone // ignore: cast_nullable_to_non_nullable
              as String,
      null == password
          ? _value.password
          : password // ignore: cast_nullable_to_non_nullable
              as String,
      null == can_receive_offers
          ? _value.can_receive_offers
          : can_receive_offers // ignore: cast_nullable_to_non_nullable
              as CAN_RECEIVE_OFFERS,
    ));
  }
}

/// @nodoc

class _$SignUpWithPhone with DiagnosticableTreeMixin implements SignUpWithPhone {
  const _$SignUpWithPhone(this.fullName, this.phone, this.password, this.can_receive_offers);

  @override
  final String fullName;
  @override
  final String phone;
  @override
  final String password;
  @override
  final CAN_RECEIVE_OFFERS can_receive_offers;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'SignUpEvents.signUpWithPhone(fullName: $fullName, phone: $phone, password: $password, can_receive_offers: $can_receive_offers)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'SignUpEvents.signUpWithPhone'))
      ..add(DiagnosticsProperty('fullName', fullName))
      ..add(DiagnosticsProperty('phone', phone))
      ..add(DiagnosticsProperty('password', password))
      ..add(DiagnosticsProperty('can_receive_offers', can_receive_offers));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SignUpWithPhone &&
            (identical(other.fullName, fullName) || other.fullName == fullName) &&
            (identical(other.phone, phone) || other.phone == phone) &&
            (identical(other.password, password) || other.password == password) &&
            (identical(other.can_receive_offers, can_receive_offers) ||
                other.can_receive_offers == can_receive_offers));
  }

  @override
  int get hashCode => Object.hash(runtimeType, fullName, phone, password, can_receive_offers);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SignUpWithPhoneCopyWith<_$SignUpWithPhone> get copyWith =>
      __$$SignUpWithPhoneCopyWithImpl<_$SignUpWithPhone>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() signUpWithGoogle,
    required TResult Function() signUpWithApple,
    required TResult Function(String fullName, String phone, String password, CAN_RECEIVE_OFFERS can_receive_offers)
        signUpWithPhone,
  }) {
    return signUpWithPhone(fullName, phone, password, can_receive_offers);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? signUpWithGoogle,
    TResult? Function()? signUpWithApple,
    TResult? Function(String fullName, String phone, String password, CAN_RECEIVE_OFFERS can_receive_offers)?
        signUpWithPhone,
  }) {
    return signUpWithPhone?.call(fullName, phone, password, can_receive_offers);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? signUpWithGoogle,
    TResult Function()? signUpWithApple,
    TResult Function(String fullName, String phone, String password, CAN_RECEIVE_OFFERS can_receive_offers)?
        signUpWithPhone,
    required TResult orElse(),
  }) {
    if (signUpWithPhone != null) {
      return signUpWithPhone(fullName, phone, password, can_receive_offers);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SignUpWithGoogle value) signUpWithGoogle,
    required TResult Function(SignUpWithApple value) signUpWithApple,
    required TResult Function(SignUpWithPhone value) signUpWithPhone,
  }) {
    return signUpWithPhone(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SignUpWithGoogle value)? signUpWithGoogle,
    TResult? Function(SignUpWithApple value)? signUpWithApple,
    TResult? Function(SignUpWithPhone value)? signUpWithPhone,
  }) {
    return signUpWithPhone?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SignUpWithGoogle value)? signUpWithGoogle,
    TResult Function(SignUpWithApple value)? signUpWithApple,
    TResult Function(SignUpWithPhone value)? signUpWithPhone,
    required TResult orElse(),
  }) {
    if (signUpWithPhone != null) {
      return signUpWithPhone(this);
    }
    return orElse();
  }
}

abstract class SignUpWithPhone implements SignUpEvents {
  const factory SignUpWithPhone(final String fullName, final String phone, final String password,
      final CAN_RECEIVE_OFFERS can_receive_offers) = _$SignUpWithPhone;

  String get fullName;
  String get phone;
  String get password;
  CAN_RECEIVE_OFFERS get can_receive_offers;
  @JsonKey(ignore: true)
  _$$SignUpWithPhoneCopyWith<_$SignUpWithPhone> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$SignUpState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialState,
    required TResult Function() isLoading,
    required TResult Function(String error) hassError,
    required TResult Function(SignUpResponse response) signedUpWithPhoneSuccessfully,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initialState,
    TResult? Function()? isLoading,
    TResult? Function(String error)? hassError,
    TResult? Function(SignUpResponse response)? signedUpWithPhoneSuccessfully,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialState,
    TResult Function()? isLoading,
    TResult Function(String error)? hassError,
    TResult Function(SignUpResponse response)? signedUpWithPhoneSuccessfully,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SignUpInitialState value) initialState,
    required TResult Function(SignUpIsLoading value) isLoading,
    required TResult Function(_HasError value) hassError,
    required TResult Function(SignedUpWithPhoneSuccessfully value) signedUpWithPhoneSuccessfully,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SignUpInitialState value)? initialState,
    TResult? Function(SignUpIsLoading value)? isLoading,
    TResult? Function(_HasError value)? hassError,
    TResult? Function(SignedUpWithPhoneSuccessfully value)? signedUpWithPhoneSuccessfully,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SignUpInitialState value)? initialState,
    TResult Function(SignUpIsLoading value)? isLoading,
    TResult Function(_HasError value)? hassError,
    TResult Function(SignedUpWithPhoneSuccessfully value)? signedUpWithPhoneSuccessfully,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SignUpStateCopyWith<$Res> {
  factory $SignUpStateCopyWith(SignUpState value, $Res Function(SignUpState) then) =
      _$SignUpStateCopyWithImpl<$Res, SignUpState>;
}

/// @nodoc
class _$SignUpStateCopyWithImpl<$Res, $Val extends SignUpState> implements $SignUpStateCopyWith<$Res> {
  _$SignUpStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$SignUpInitialStateCopyWith<$Res> {
  factory _$$SignUpInitialStateCopyWith(_$SignUpInitialState value, $Res Function(_$SignUpInitialState) then) =
      __$$SignUpInitialStateCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SignUpInitialStateCopyWithImpl<$Res> extends _$SignUpStateCopyWithImpl<$Res, _$SignUpInitialState>
    implements _$$SignUpInitialStateCopyWith<$Res> {
  __$$SignUpInitialStateCopyWithImpl(_$SignUpInitialState _value, $Res Function(_$SignUpInitialState) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SignUpInitialState with DiagnosticableTreeMixin implements SignUpInitialState {
  const _$SignUpInitialState();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'SignUpState.initialState()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'SignUpState.initialState'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other.runtimeType == runtimeType && other is _$SignUpInitialState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialState,
    required TResult Function() isLoading,
    required TResult Function(String error) hassError,
    required TResult Function(SignUpResponse response) signedUpWithPhoneSuccessfully,
  }) {
    return initialState();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initialState,
    TResult? Function()? isLoading,
    TResult? Function(String error)? hassError,
    TResult? Function(SignUpResponse response)? signedUpWithPhoneSuccessfully,
  }) {
    return initialState?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialState,
    TResult Function()? isLoading,
    TResult Function(String error)? hassError,
    TResult Function(SignUpResponse response)? signedUpWithPhoneSuccessfully,
    required TResult orElse(),
  }) {
    if (initialState != null) {
      return initialState();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SignUpInitialState value) initialState,
    required TResult Function(SignUpIsLoading value) isLoading,
    required TResult Function(_HasError value) hassError,
    required TResult Function(SignedUpWithPhoneSuccessfully value) signedUpWithPhoneSuccessfully,
  }) {
    return initialState(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SignUpInitialState value)? initialState,
    TResult? Function(SignUpIsLoading value)? isLoading,
    TResult? Function(_HasError value)? hassError,
    TResult? Function(SignedUpWithPhoneSuccessfully value)? signedUpWithPhoneSuccessfully,
  }) {
    return initialState?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SignUpInitialState value)? initialState,
    TResult Function(SignUpIsLoading value)? isLoading,
    TResult Function(_HasError value)? hassError,
    TResult Function(SignedUpWithPhoneSuccessfully value)? signedUpWithPhoneSuccessfully,
    required TResult orElse(),
  }) {
    if (initialState != null) {
      return initialState(this);
    }
    return orElse();
  }
}

abstract class SignUpInitialState implements SignUpState {
  const factory SignUpInitialState() = _$SignUpInitialState;
}

/// @nodoc
abstract class _$$SignUpIsLoadingCopyWith<$Res> {
  factory _$$SignUpIsLoadingCopyWith(_$SignUpIsLoading value, $Res Function(_$SignUpIsLoading) then) =
      __$$SignUpIsLoadingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SignUpIsLoadingCopyWithImpl<$Res> extends _$SignUpStateCopyWithImpl<$Res, _$SignUpIsLoading>
    implements _$$SignUpIsLoadingCopyWith<$Res> {
  __$$SignUpIsLoadingCopyWithImpl(_$SignUpIsLoading _value, $Res Function(_$SignUpIsLoading) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SignUpIsLoading with DiagnosticableTreeMixin implements SignUpIsLoading {
  const _$SignUpIsLoading();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'SignUpState.isLoading()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'SignUpState.isLoading'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other.runtimeType == runtimeType && other is _$SignUpIsLoading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialState,
    required TResult Function() isLoading,
    required TResult Function(String error) hassError,
    required TResult Function(SignUpResponse response) signedUpWithPhoneSuccessfully,
  }) {
    return isLoading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initialState,
    TResult? Function()? isLoading,
    TResult? Function(String error)? hassError,
    TResult? Function(SignUpResponse response)? signedUpWithPhoneSuccessfully,
  }) {
    return isLoading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialState,
    TResult Function()? isLoading,
    TResult Function(String error)? hassError,
    TResult Function(SignUpResponse response)? signedUpWithPhoneSuccessfully,
    required TResult orElse(),
  }) {
    if (isLoading != null) {
      return isLoading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SignUpInitialState value) initialState,
    required TResult Function(SignUpIsLoading value) isLoading,
    required TResult Function(_HasError value) hassError,
    required TResult Function(SignedUpWithPhoneSuccessfully value) signedUpWithPhoneSuccessfully,
  }) {
    return isLoading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SignUpInitialState value)? initialState,
    TResult? Function(SignUpIsLoading value)? isLoading,
    TResult? Function(_HasError value)? hassError,
    TResult? Function(SignedUpWithPhoneSuccessfully value)? signedUpWithPhoneSuccessfully,
  }) {
    return isLoading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SignUpInitialState value)? initialState,
    TResult Function(SignUpIsLoading value)? isLoading,
    TResult Function(_HasError value)? hassError,
    TResult Function(SignedUpWithPhoneSuccessfully value)? signedUpWithPhoneSuccessfully,
    required TResult orElse(),
  }) {
    if (isLoading != null) {
      return isLoading(this);
    }
    return orElse();
  }
}

abstract class SignUpIsLoading implements SignUpState {
  const factory SignUpIsLoading() = _$SignUpIsLoading;
}

/// @nodoc
abstract class _$$_HasErrorCopyWith<$Res> {
  factory _$$_HasErrorCopyWith(_$_HasError value, $Res Function(_$_HasError) then) = __$$_HasErrorCopyWithImpl<$Res>;
  @useResult
  $Res call({String error});
}

/// @nodoc
class __$$_HasErrorCopyWithImpl<$Res> extends _$SignUpStateCopyWithImpl<$Res, _$_HasError>
    implements _$$_HasErrorCopyWith<$Res> {
  __$$_HasErrorCopyWithImpl(_$_HasError _value, $Res Function(_$_HasError) _then) : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = null,
  }) {
    return _then(_$_HasError(
      null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_HasError with DiagnosticableTreeMixin implements _HasError {
  const _$_HasError(this.error);

  @override
  final String error;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'SignUpState.hassError(error: $error)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'SignUpState.hassError'))
      ..add(DiagnosticsProperty('error', error));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_HasError &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_HasErrorCopyWith<_$_HasError> get copyWith => __$$_HasErrorCopyWithImpl<_$_HasError>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialState,
    required TResult Function() isLoading,
    required TResult Function(String error) hassError,
    required TResult Function(SignUpResponse response) signedUpWithPhoneSuccessfully,
  }) {
    return hassError(error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initialState,
    TResult? Function()? isLoading,
    TResult? Function(String error)? hassError,
    TResult? Function(SignUpResponse response)? signedUpWithPhoneSuccessfully,
  }) {
    return hassError?.call(error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialState,
    TResult Function()? isLoading,
    TResult Function(String error)? hassError,
    TResult Function(SignUpResponse response)? signedUpWithPhoneSuccessfully,
    required TResult orElse(),
  }) {
    if (hassError != null) {
      return hassError(error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SignUpInitialState value) initialState,
    required TResult Function(SignUpIsLoading value) isLoading,
    required TResult Function(_HasError value) hassError,
    required TResult Function(SignedUpWithPhoneSuccessfully value) signedUpWithPhoneSuccessfully,
  }) {
    return hassError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SignUpInitialState value)? initialState,
    TResult? Function(SignUpIsLoading value)? isLoading,
    TResult? Function(_HasError value)? hassError,
    TResult? Function(SignedUpWithPhoneSuccessfully value)? signedUpWithPhoneSuccessfully,
  }) {
    return hassError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SignUpInitialState value)? initialState,
    TResult Function(SignUpIsLoading value)? isLoading,
    TResult Function(_HasError value)? hassError,
    TResult Function(SignedUpWithPhoneSuccessfully value)? signedUpWithPhoneSuccessfully,
    required TResult orElse(),
  }) {
    if (hassError != null) {
      return hassError(this);
    }
    return orElse();
  }
}

abstract class _HasError implements SignUpState {
  const factory _HasError(final String error) = _$_HasError;

  String get error;
  @JsonKey(ignore: true)
  _$$_HasErrorCopyWith<_$_HasError> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SignedUpWithPhoneSuccessfullyCopyWith<$Res> {
  factory _$$SignedUpWithPhoneSuccessfullyCopyWith(
          _$SignedUpWithPhoneSuccessfully value, $Res Function(_$SignedUpWithPhoneSuccessfully) then) =
      __$$SignedUpWithPhoneSuccessfullyCopyWithImpl<$Res>;
  @useResult
  $Res call({SignUpResponse response});

  $SignUpResponseCopyWith<$Res> get response;
}

/// @nodoc
class __$$SignedUpWithPhoneSuccessfullyCopyWithImpl<$Res>
    extends _$SignUpStateCopyWithImpl<$Res, _$SignedUpWithPhoneSuccessfully>
    implements _$$SignedUpWithPhoneSuccessfullyCopyWith<$Res> {
  __$$SignedUpWithPhoneSuccessfullyCopyWithImpl(
      _$SignedUpWithPhoneSuccessfully _value, $Res Function(_$SignedUpWithPhoneSuccessfully) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? response = null,
  }) {
    return _then(_$SignedUpWithPhoneSuccessfully(
      null == response
          ? _value.response
          : response // ignore: cast_nullable_to_non_nullable
              as SignUpResponse,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $SignUpResponseCopyWith<$Res> get response {
    return $SignUpResponseCopyWith<$Res>(_value.response, (value) {
      return _then(_value.copyWith(response: value));
    });
  }
}

/// @nodoc

class _$SignedUpWithPhoneSuccessfully with DiagnosticableTreeMixin implements SignedUpWithPhoneSuccessfully {
  const _$SignedUpWithPhoneSuccessfully(this.response);

  @override
  final SignUpResponse response;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'SignUpState.signedUpWithPhoneSuccessfully(response: $response)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'SignUpState.signedUpWithPhoneSuccessfully'))
      ..add(DiagnosticsProperty('response', response));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SignedUpWithPhoneSuccessfully &&
            (identical(other.response, response) || other.response == response));
  }

  @override
  int get hashCode => Object.hash(runtimeType, response);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SignedUpWithPhoneSuccessfullyCopyWith<_$SignedUpWithPhoneSuccessfully> get copyWith =>
      __$$SignedUpWithPhoneSuccessfullyCopyWithImpl<_$SignedUpWithPhoneSuccessfully>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initialState,
    required TResult Function() isLoading,
    required TResult Function(String error) hassError,
    required TResult Function(SignUpResponse response) signedUpWithPhoneSuccessfully,
  }) {
    return signedUpWithPhoneSuccessfully(response);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initialState,
    TResult? Function()? isLoading,
    TResult? Function(String error)? hassError,
    TResult? Function(SignUpResponse response)? signedUpWithPhoneSuccessfully,
  }) {
    return signedUpWithPhoneSuccessfully?.call(response);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initialState,
    TResult Function()? isLoading,
    TResult Function(String error)? hassError,
    TResult Function(SignUpResponse response)? signedUpWithPhoneSuccessfully,
    required TResult orElse(),
  }) {
    if (signedUpWithPhoneSuccessfully != null) {
      return signedUpWithPhoneSuccessfully(response);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SignUpInitialState value) initialState,
    required TResult Function(SignUpIsLoading value) isLoading,
    required TResult Function(_HasError value) hassError,
    required TResult Function(SignedUpWithPhoneSuccessfully value) signedUpWithPhoneSuccessfully,
  }) {
    return signedUpWithPhoneSuccessfully(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SignUpInitialState value)? initialState,
    TResult? Function(SignUpIsLoading value)? isLoading,
    TResult? Function(_HasError value)? hassError,
    TResult? Function(SignedUpWithPhoneSuccessfully value)? signedUpWithPhoneSuccessfully,
  }) {
    return signedUpWithPhoneSuccessfully?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SignUpInitialState value)? initialState,
    TResult Function(SignUpIsLoading value)? isLoading,
    TResult Function(_HasError value)? hassError,
    TResult Function(SignedUpWithPhoneSuccessfully value)? signedUpWithPhoneSuccessfully,
    required TResult orElse(),
  }) {
    if (signedUpWithPhoneSuccessfully != null) {
      return signedUpWithPhoneSuccessfully(this);
    }
    return orElse();
  }
}

abstract class SignedUpWithPhoneSuccessfully implements SignUpState {
  const factory SignedUpWithPhoneSuccessfully(final SignUpResponse response) = _$SignedUpWithPhoneSuccessfully;

  SignUpResponse get response;
  @JsonKey(ignore: true)
  _$$SignedUpWithPhoneSuccessfullyCopyWith<_$SignedUpWithPhoneSuccessfully> get copyWith =>
      throw _privateConstructorUsedError;
}
