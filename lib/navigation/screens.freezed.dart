// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'screens.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$UiScreensTearOff {
  const _$UiScreensTearOff();

  Splash splash() {
    return const Splash();
  }

  Landing landing() {
    return const Landing();
  }

  Login login() {
    return const Login();
  }

  SignUp signUp() {
    return const SignUp();
  }

  Otp otp() {
    return const Otp();
  }

  Home home() {
    return const Home();
  }
}

/// @nodoc
const $UiScreens = _$UiScreensTearOff();

/// @nodoc
mixin _$UiScreens {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() splash,
    required TResult Function() landing,
    required TResult Function() login,
    required TResult Function() signUp,
    required TResult Function() otp,
    required TResult Function() home,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? splash,
    TResult Function()? landing,
    TResult Function()? login,
    TResult Function()? signUp,
    TResult Function()? otp,
    TResult Function()? home,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Splash value) splash,
    required TResult Function(Landing value) landing,
    required TResult Function(Login value) login,
    required TResult Function(SignUp value) signUp,
    required TResult Function(Otp value) otp,
    required TResult Function(Home value) home,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Splash value)? splash,
    TResult Function(Landing value)? landing,
    TResult Function(Login value)? login,
    TResult Function(SignUp value)? signUp,
    TResult Function(Otp value)? otp,
    TResult Function(Home value)? home,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UiScreensCopyWith<$Res> {
  factory $UiScreensCopyWith(UiScreens value, $Res Function(UiScreens) then) =
      _$UiScreensCopyWithImpl<$Res>;
}

/// @nodoc
class _$UiScreensCopyWithImpl<$Res> implements $UiScreensCopyWith<$Res> {
  _$UiScreensCopyWithImpl(this._value, this._then);

  final UiScreens _value;
  // ignore: unused_field
  final $Res Function(UiScreens) _then;
}

/// @nodoc
abstract class $SplashCopyWith<$Res> {
  factory $SplashCopyWith(Splash value, $Res Function(Splash) then) =
      _$SplashCopyWithImpl<$Res>;
}

/// @nodoc
class _$SplashCopyWithImpl<$Res> extends _$UiScreensCopyWithImpl<$Res>
    implements $SplashCopyWith<$Res> {
  _$SplashCopyWithImpl(Splash _value, $Res Function(Splash) _then)
      : super(_value, (v) => _then(v as Splash));

  @override
  Splash get _value => super._value as Splash;
}

/// @nodoc

class _$Splash implements Splash {
  const _$Splash();

  @override
  String toString() {
    return 'UiScreens.splash()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is Splash);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() splash,
    required TResult Function() landing,
    required TResult Function() login,
    required TResult Function() signUp,
    required TResult Function() otp,
    required TResult Function() home,
  }) {
    return splash();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? splash,
    TResult Function()? landing,
    TResult Function()? login,
    TResult Function()? signUp,
    TResult Function()? otp,
    TResult Function()? home,
    required TResult orElse(),
  }) {
    if (splash != null) {
      return splash();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Splash value) splash,
    required TResult Function(Landing value) landing,
    required TResult Function(Login value) login,
    required TResult Function(SignUp value) signUp,
    required TResult Function(Otp value) otp,
    required TResult Function(Home value) home,
  }) {
    return splash(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Splash value)? splash,
    TResult Function(Landing value)? landing,
    TResult Function(Login value)? login,
    TResult Function(SignUp value)? signUp,
    TResult Function(Otp value)? otp,
    TResult Function(Home value)? home,
    required TResult orElse(),
  }) {
    if (splash != null) {
      return splash(this);
    }
    return orElse();
  }
}

abstract class Splash implements UiScreens {
  const factory Splash() = _$Splash;
}

/// @nodoc
abstract class $LandingCopyWith<$Res> {
  factory $LandingCopyWith(Landing value, $Res Function(Landing) then) =
      _$LandingCopyWithImpl<$Res>;
}

/// @nodoc
class _$LandingCopyWithImpl<$Res> extends _$UiScreensCopyWithImpl<$Res>
    implements $LandingCopyWith<$Res> {
  _$LandingCopyWithImpl(Landing _value, $Res Function(Landing) _then)
      : super(_value, (v) => _then(v as Landing));

  @override
  Landing get _value => super._value as Landing;
}

/// @nodoc

class _$Landing implements Landing {
  const _$Landing();

  @override
  String toString() {
    return 'UiScreens.landing()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is Landing);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() splash,
    required TResult Function() landing,
    required TResult Function() login,
    required TResult Function() signUp,
    required TResult Function() otp,
    required TResult Function() home,
  }) {
    return landing();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? splash,
    TResult Function()? landing,
    TResult Function()? login,
    TResult Function()? signUp,
    TResult Function()? otp,
    TResult Function()? home,
    required TResult orElse(),
  }) {
    if (landing != null) {
      return landing();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Splash value) splash,
    required TResult Function(Landing value) landing,
    required TResult Function(Login value) login,
    required TResult Function(SignUp value) signUp,
    required TResult Function(Otp value) otp,
    required TResult Function(Home value) home,
  }) {
    return landing(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Splash value)? splash,
    TResult Function(Landing value)? landing,
    TResult Function(Login value)? login,
    TResult Function(SignUp value)? signUp,
    TResult Function(Otp value)? otp,
    TResult Function(Home value)? home,
    required TResult orElse(),
  }) {
    if (landing != null) {
      return landing(this);
    }
    return orElse();
  }
}

abstract class Landing implements UiScreens {
  const factory Landing() = _$Landing;
}

/// @nodoc
abstract class $LoginCopyWith<$Res> {
  factory $LoginCopyWith(Login value, $Res Function(Login) then) =
      _$LoginCopyWithImpl<$Res>;
}

/// @nodoc
class _$LoginCopyWithImpl<$Res> extends _$UiScreensCopyWithImpl<$Res>
    implements $LoginCopyWith<$Res> {
  _$LoginCopyWithImpl(Login _value, $Res Function(Login) _then)
      : super(_value, (v) => _then(v as Login));

  @override
  Login get _value => super._value as Login;
}

/// @nodoc

class _$Login implements Login {
  const _$Login();

  @override
  String toString() {
    return 'UiScreens.login()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is Login);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() splash,
    required TResult Function() landing,
    required TResult Function() login,
    required TResult Function() signUp,
    required TResult Function() otp,
    required TResult Function() home,
  }) {
    return login();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? splash,
    TResult Function()? landing,
    TResult Function()? login,
    TResult Function()? signUp,
    TResult Function()? otp,
    TResult Function()? home,
    required TResult orElse(),
  }) {
    if (login != null) {
      return login();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Splash value) splash,
    required TResult Function(Landing value) landing,
    required TResult Function(Login value) login,
    required TResult Function(SignUp value) signUp,
    required TResult Function(Otp value) otp,
    required TResult Function(Home value) home,
  }) {
    return login(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Splash value)? splash,
    TResult Function(Landing value)? landing,
    TResult Function(Login value)? login,
    TResult Function(SignUp value)? signUp,
    TResult Function(Otp value)? otp,
    TResult Function(Home value)? home,
    required TResult orElse(),
  }) {
    if (login != null) {
      return login(this);
    }
    return orElse();
  }
}

abstract class Login implements UiScreens {
  const factory Login() = _$Login;
}

/// @nodoc
abstract class $SignUpCopyWith<$Res> {
  factory $SignUpCopyWith(SignUp value, $Res Function(SignUp) then) =
      _$SignUpCopyWithImpl<$Res>;
}

/// @nodoc
class _$SignUpCopyWithImpl<$Res> extends _$UiScreensCopyWithImpl<$Res>
    implements $SignUpCopyWith<$Res> {
  _$SignUpCopyWithImpl(SignUp _value, $Res Function(SignUp) _then)
      : super(_value, (v) => _then(v as SignUp));

  @override
  SignUp get _value => super._value as SignUp;
}

/// @nodoc

class _$SignUp implements SignUp {
  const _$SignUp();

  @override
  String toString() {
    return 'UiScreens.signUp()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is SignUp);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() splash,
    required TResult Function() landing,
    required TResult Function() login,
    required TResult Function() signUp,
    required TResult Function() otp,
    required TResult Function() home,
  }) {
    return signUp();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? splash,
    TResult Function()? landing,
    TResult Function()? login,
    TResult Function()? signUp,
    TResult Function()? otp,
    TResult Function()? home,
    required TResult orElse(),
  }) {
    if (signUp != null) {
      return signUp();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Splash value) splash,
    required TResult Function(Landing value) landing,
    required TResult Function(Login value) login,
    required TResult Function(SignUp value) signUp,
    required TResult Function(Otp value) otp,
    required TResult Function(Home value) home,
  }) {
    return signUp(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Splash value)? splash,
    TResult Function(Landing value)? landing,
    TResult Function(Login value)? login,
    TResult Function(SignUp value)? signUp,
    TResult Function(Otp value)? otp,
    TResult Function(Home value)? home,
    required TResult orElse(),
  }) {
    if (signUp != null) {
      return signUp(this);
    }
    return orElse();
  }
}

abstract class SignUp implements UiScreens {
  const factory SignUp() = _$SignUp;
}

/// @nodoc
abstract class $OtpCopyWith<$Res> {
  factory $OtpCopyWith(Otp value, $Res Function(Otp) then) =
      _$OtpCopyWithImpl<$Res>;
}

/// @nodoc
class _$OtpCopyWithImpl<$Res> extends _$UiScreensCopyWithImpl<$Res>
    implements $OtpCopyWith<$Res> {
  _$OtpCopyWithImpl(Otp _value, $Res Function(Otp) _then)
      : super(_value, (v) => _then(v as Otp));

  @override
  Otp get _value => super._value as Otp;
}

/// @nodoc

class _$Otp implements Otp {
  const _$Otp();

  @override
  String toString() {
    return 'UiScreens.otp()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is Otp);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() splash,
    required TResult Function() landing,
    required TResult Function() login,
    required TResult Function() signUp,
    required TResult Function() otp,
    required TResult Function() home,
  }) {
    return otp();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? splash,
    TResult Function()? landing,
    TResult Function()? login,
    TResult Function()? signUp,
    TResult Function()? otp,
    TResult Function()? home,
    required TResult orElse(),
  }) {
    if (otp != null) {
      return otp();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Splash value) splash,
    required TResult Function(Landing value) landing,
    required TResult Function(Login value) login,
    required TResult Function(SignUp value) signUp,
    required TResult Function(Otp value) otp,
    required TResult Function(Home value) home,
  }) {
    return otp(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Splash value)? splash,
    TResult Function(Landing value)? landing,
    TResult Function(Login value)? login,
    TResult Function(SignUp value)? signUp,
    TResult Function(Otp value)? otp,
    TResult Function(Home value)? home,
    required TResult orElse(),
  }) {
    if (otp != null) {
      return otp(this);
    }
    return orElse();
  }
}

abstract class Otp implements UiScreens {
  const factory Otp() = _$Otp;
}

/// @nodoc
abstract class $HomeCopyWith<$Res> {
  factory $HomeCopyWith(Home value, $Res Function(Home) then) =
      _$HomeCopyWithImpl<$Res>;
}

/// @nodoc
class _$HomeCopyWithImpl<$Res> extends _$UiScreensCopyWithImpl<$Res>
    implements $HomeCopyWith<$Res> {
  _$HomeCopyWithImpl(Home _value, $Res Function(Home) _then)
      : super(_value, (v) => _then(v as Home));

  @override
  Home get _value => super._value as Home;
}

/// @nodoc

class _$Home implements Home {
  const _$Home();

  @override
  String toString() {
    return 'UiScreens.home()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is Home);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() splash,
    required TResult Function() landing,
    required TResult Function() login,
    required TResult Function() signUp,
    required TResult Function() otp,
    required TResult Function() home,
  }) {
    return home();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? splash,
    TResult Function()? landing,
    TResult Function()? login,
    TResult Function()? signUp,
    TResult Function()? otp,
    TResult Function()? home,
    required TResult orElse(),
  }) {
    if (home != null) {
      return home();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Splash value) splash,
    required TResult Function(Landing value) landing,
    required TResult Function(Login value) login,
    required TResult Function(SignUp value) signUp,
    required TResult Function(Otp value) otp,
    required TResult Function(Home value) home,
  }) {
    return home(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Splash value)? splash,
    TResult Function(Landing value)? landing,
    TResult Function(Login value)? login,
    TResult Function(SignUp value)? signUp,
    TResult Function(Otp value)? otp,
    TResult Function(Home value)? home,
    required TResult orElse(),
  }) {
    if (home != null) {
      return home(this);
    }
    return orElse();
  }
}

abstract class Home implements UiScreens {
  const factory Home() = _$Home;
}
